from fastapi import FastAPI, Depends, HTTPException, Form, Request

# --- minimaler Reports-Platzhalter (bis echte Pulls aktiviert sind) ---
def fetch_reports_and_upsert_stub(*args, **kwargs):
    return {"status": "ok", "pulled": 0}
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from .db import Base, engine, get_db
from . import models, schemas
from .settings import settings
from .sp_api import pull_orders
from .sp_api_reports_patch import fetch_returns_rows, fetch_removals_rows, fetch_adjustments_rows, fetch_reimbursements_rows
from .services import reconcile_account

Base.metadata.create_all(bind=engine)

def _try_parse_dt(v):
    from datetime import datetime
    if not v:
        return None
    v = v.replace("Z", "+00:00") if isinstance(v,str) else v
    try:
        return datetime.fromisoformat(v)
    except Exception:
        return None

app = FastAPI(title="Seller-Control (Multi-Account)")
from .oauth import router as oauth_router
app.include_router(oauth_router)

app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

@app.get("/", response_class=HTMLResponse)
def dashboard(request: Request, db: Session = Depends(get_db)):
    accounts = db.query(models.SellerAccount).all()
    return templates.TemplateResponse("index.html", {"request": request, "accounts": accounts})

@app.get("/api/accounts")
def list_accounts(db: Session = Depends(get_db)):
    rows = db.query(models.SellerAccount).all()
    return [schemas.SellerAccountOut.model_validate(r).model_dump() for r in rows]

@app.post("/api/accounts", response_model=schemas.SellerAccountOut)
def add_account(payload: schemas.SellerAccountIn, db: Session = Depends(get_db)):
    acc = models.SellerAccount(**payload.model_dump())
    db.add(acc)
    db.commit()
    db.refresh(acc)
    return schemas.SellerAccountOut.model_validate(acc)

@app.post("/api/accounts/{account_id}/toggle")
def toggle_account(account_id: int, db: Session = Depends(get_db)):
    acc = db.get(models.SellerAccount, account_id)
    if not acc:
        raise HTTPException(404, "Account not found")
    acc.is_active = not acc.is_active
    db.commit()
    return {"id": acc.id, "is_active": acc.is_active}

@app.post("/api/orders/sync")
def sync_orders(account_id: int, days: int = 7, db: Session = Depends(get_db)):
    acc = db.get(models.SellerAccount, account_id)
    if not acc:
        return HTMLResponse("<div class='text-red-700'>Account nicht gefunden.</div>", status_code=200)

    # Marketplaces aus dem Konto (z. B. "DE,FR,IT")
    marketplaces = [m.strip().upper() for m in (acc.marketplaces or "DE").split(",") if m.strip()]

    # Bestellungen ziehen (nutzt unsere LWA-only Signierung im sp_api)
    orders = pull_orders(
        account_id=acc.id,
        enc_refresh_token=acc.refresh_token,
        marketplaces=marketplaces,
        days=days,
    )

    inserted = 0
    for o in orders:
        db.add(models.Order(
            account_id=acc.id,
            order_id=o.get("orderId"),
            purchase_date=_try_parse_dt(o.get("purchaseDate")),
            status=o.get("status") or "",
            marketplace=o.get("marketplaceId") or "",
            data=o,
        ))
        inserted += 1

    db.commit()
    return {"synced": inserted}


@app.post("/api/reports/pull", response_class=HTMLResponse)
def pull_reports(account_id: int, days: int = 30, db: Session = Depends(get_db)):
    from .sp_api_reports_patch import (
        fetch_returns_rows, fetch_removals_rows,
        fetch_adjustments_rows, fetch_reimbursements_rows
    acc = db.get(models.SellerAccount, account_id)
    if not acc:
        return HTMLResponse("<div class='text-red-700'>Account nicht gefunden.</div>", status_code=200)

    # SP-API Reports brauchen etwas Puffer; wir nehmen 5 Minuten
    now = datetime.utcnow()
    safe_end = now - timedelta(minutes=5)
    safe_start = safe_end - timedelta(days=days)

    rets = fetch_returns_rows(acc.id, acc.refresh_token, safe_start, safe_end)
    rems = fetch_removals_rows(acc.id, acc.refresh_token, safe_start, safe_end)
    adjs = fetch_adjustments_rows(acc.id, acc.refresh_token, safe_start, safe_end)
    reims = fetch_reimbursements_rows(acc.id, acc.refresh_token, safe_start, safe_end)

    # Debug ins Container-Log
    print(f"[reports] returns={len(rets)} removals={len(rems)} adjustments={len(adjs)} reimbursements={len(reims)} window={safe_start}..{safe_end}")

    # Speichern
    from decimal import Decimal
    for r in rets:
        db.add(models.FbaReturn(
            account_id=acc.id,
            return_date=_try_parse_dt(r.get("return_date")),
            order_id=r.get("order_id"), asin=r.get("asin"), sku=r.get("sku"),
            disposition=r.get("disposition"), reason=r.get("reason"),
            quantity=r.get("quantity"), fc=r.get("fc"), raw=r.get("raw")
        ))
    for r in rems:
        db.add(models.FbaRemoval(
            account_id=acc.id,
            removal_order_id=r.get("removal_order_id"),
            order_type=r.get("order_type"), status=r.get("status"),
            request_date=_try_parse_dt(r.get("request_date")),
            shipped_date=_try_parse_dt(r.get("shipped_date")),
            received_date=_try_parse_dt(r.get("received_date")),
            asin=r.get("asin"), sku=r.get("sku"),
            quantity=r.get("quantity"), disposition=r.get("disposition"),
            raw=r.get("raw")
        ))
    for r in adjs:
        db.add(models.FbaInventoryAdjustment(
            account_id=acc.id,
            adjustment_date=_try_parse_dt(r.get("adjustment_date")),
            asin=r.get("asin"), sku=r.get("sku"),
            quantity=r.get("quantity"), reason=r.get("reason"), fc=r.get("fc"),
            raw=r.get("raw")
        ))
    for r in reims:
        amt = Decimal(str(r.get("amount") if r.get("amount") is not None else "0"))
        db.add(models.FbaReimbursement(
            account_id=acc.id,
            posted_date=_try_parse_dt(r.get("posted_date")),
            case_id=r.get("case_id"),
            asin=r.get("asin"), sku=r.get("sku"),
            quantity=r.get("quantity"),
            amount=amt,
            currency=r.get("currency"),
            reason=r.get("reason"),
            raw=r.get("raw")
        ))
    db.commit()

    # Sichtbarer Toast
    msg = f"Reports: returns={len(rets)}, removals={len(rems)}, adjustments={len(adjs)}, reimbursements={len(reims)}"
    if (len(rets)+len(rems)+len(adjs)+len(reims)) == 0:
        msg += " — (Hinweis: Zeitraum/Permissions? Endzeit >=5 Min Puffer; Rollen 'Versand durch Amazon' & 'Lagerbestand' aktiviert?)"
    return HTMLResponse(f"<div class='text-green-700'>{msg}</div>", status_code=200)

    except Exception as e:
        return HTMLResponse(f"<div class='text-red-700'>Fehler: {e}</div>", status_code=200)


# --- Account bearbeiten: Formular laden ---
@app.get("/api/accounts/{account_id}/edit", response_class=HTMLResponse)
def edit_account_form(account_id: int, db: Session = Depends(get_db)):
    acc = db.get(models.SellerAccount, account_id)
    if not acc:
        return HTMLResponse("<div class='text-red-700'>Account nicht gefunden.</div>", status_code=200)
    # Einfaches Inline-Formular (HTMX)
    html = f"""
    <form hx-post="/api/accounts/{acc.id}/update" hx-target="#toast" hx-swap="innerHTML"
          class="p-3 border rounded-xl bg-white shadow-sm space-y-3">
      <div>
        <label class="block text-sm mb-1">Name</label>
        <input name="name" value="{acc.name or ''}" class="w-full border rounded px-2 py-1"/>
      </div>
      <div class="grid grid-cols-2 gap-3">
        <div>
          <label class="block text-sm mb-1">Region</label>
          <input name="region" value="{acc.region or 'eu'}" class="w-full border rounded px-2 py-1"/>
        </div>
        <div>
          <label class="block text-sm mb-1">Marketplaces (CSV)</label>
          <input name="marketplaces" value="{acc.marketplaces or 'DE'}" class="w-full border rounded px-2 py-1"/>
        </div>
      </div>
      <div>
        <label class="block text-sm mb-1">Neuer LWA Refresh Token (optional)</label>
        <input name="refresh_token" placeholder="leer lassen = unverändert" class="w-full border rounded px-2 py-1"/>
      </div>
      <div class="flex gap-2 pt-2">
        <button class="px-3 py-1 rounded-lg border">Speichern</button>
        <button type="button" class="px-3 py-1 rounded-lg border"
                onclick="document.getElementById('acc-{acc.id}-edit').innerHTML=''">Abbrechen</button>
      </div>
    </form>
    """
    return HTMLResponse(html, status_code=200)

# --- Account bearbeiten: Speichern ---
@app.post("/api/accounts/{account_id}/update", response_class=HTMLResponse)
def update_account(account_id: int,
                   name: str = Form(""),
                   region: str = Form(""),
                   marketplaces: str = Form(""),
                   refresh_token: str = Form(""),
                   db: Session = Depends(get_db)):
    from .crypto import encrypt
    acc = db.get(models.SellerAccount, account_id)
    if not acc:
        return HTMLResponse("<div class='text-red-700'>Account nicht gefunden.</div>", status_code=200)

    # Felder übernehmen (leer = unverändert)
    acc.name = (name or acc.name).strip()
    acc.region = (region or acc.region or "eu").strip()
    acc.marketplaces = (marketplaces or acc.marketplaces or "DE").strip()
    if refresh_token and refresh_token.strip():
        acc.refresh_token = encrypt(refresh_token.strip())

    db.commit()
    # Erfolg + Seite neu laden, damit Card sofort aktualisiert ist
    return HTMLResponse("<div class='text-green-700'>Konto aktualisiert. Lade neu …</div><script>location.reload()</script>", status_code=200)

@app.post("/api/accounts", response_class=HTMLResponse)
def create_account(
    name: str = Form(...),
    region: str = Form(...),
    marketplaces: str = Form(...),
    lwa_refresh_token: str = Form(""),
    db: Session = Depends(get_db),
):
    # Neues Konto anlegen
    acc = models.SellerAccount(
        name=(name or "").strip() or "Hauptkonto",
        region=(region or "").strip() or "eu",
        marketplaces=(marketplaces or "").strip() or "DE,FR,IT,ES",
        refresh_token=encrypt((lwa_refresh_token or "").strip()) if lwa_refresh_token else None,
        active=True,
    db.add(acc)
    db.commit()
    db.refresh(acc)

@app.post("/api/accounts", response_class=HTMLResponse)
def create_account(
    name: str = Form(...),
    region: str = Form(...),
    marketplaces: str = Form(...),
    lwa_refresh_token: str = Form(""),
    db: Session = Depends(get_db),
):
    acc = models.SellerAccount(
        name=(name or "").strip() or "Hauptkonto",
        region=(region or "").strip() or "eu",
        marketplaces=(marketplaces or "").strip() or "DE,FR,IT,ES",
        refresh_token=encrypt((lwa_refresh_token or "").strip()) if lwa_refresh_token else None,
        active=True,
    db.add(acc)
    db.commit()
    db.refresh(acc)
    return HTMLResponse(f"<div class='text-green-700'>Konto {acc.name} angelegt (ID {acc.id}).</div>", status_code=200)

@app.post("/api/accounts", response_class=HTMLResponse)
def create_account(
    name: str = Form(...),
    region: str = Form(...),
    marketplaces: str = Form(...),
    lwa_refresh_token: str = Form(""),
    db: Session = Depends(get_db),
):
    acc = models.SellerAccount(
        name=(name or "").strip() or "Hauptkonto",
        region=(region or "").strip() or "eu",
        marketplaces=(marketplaces or "").strip() or "DE",
        refresh_token=encrypt((lwa_refresh_token or "").strip()) if lwa_refresh_token else None,
        active=True,
    db.add(acc)
    db.commit()
    db.refresh(acc)
    return HTMLResponse(f"<div class='text-green-700'>Konto {acc.name} angelegt (ID {acc.id}).</div>", status_code=200)

@app.post("/api/accounts", response_class=HTMLResponse)
def create_account(
    name: str = Form(...),
    region: str = Form(...),
    marketplaces: str = Form(...),
    lwa_refresh_token: str = Form(""),
    db: Session = Depends(get_db),
):
    acc = models.SellerAccount(
        name=(name or "").strip() or "Hauptkonto",
        region=(region or "").strip() or "eu",
        marketplaces=(marketplaces or "").strip() or "DE",
        refresh_token=encrypt((lwa_refresh_token or "").strip()) if lwa_refresh_token else None,
        active=True,
    db.add(acc)
    db.commit()
    db.refresh(acc)
    return HTMLResponse(f"<div class='text-green-700'>Konto {acc.name} angelegt (ID {acc.id}).</div>", status_code=200)
